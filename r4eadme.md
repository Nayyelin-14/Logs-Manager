# Log Management System (LMS)

A high-performance, enterprise-grade **Log Management System** with real-time alerting, analytics, and role-based access control. Built with modern technologies for scalability, reliability, and exceptional user experience.

![License](https://img.shields.io/badge/license-MIT-blue.svg)
![Node](https://img.shields.io/badge/node-%3E%3D18.0.0-brightgreen)
![React](https://img.shields.io/badge/react-19-blue)
![TypeScript](https://img.shields.io/badge/typescript-5.0-blue)

---

## üéØ Overview

The LMS provides a comprehensive solution for ingesting, normalizing, storing, and analyzing logs from multiple sources. It features real-time alert evaluation, automated notifications, role-based access control, and powerful analytics dashboards.

### Key Capabilities

- **Multi-Source Log Ingestion**: HTTP, Syslog, Network feeds, CrowdStrike, and custom agents
- **Real-Time Alerting**: Rule-based evaluation with customizable thresholds
- **Advanced Analytics**: Interactive dashboards with filtering, search, and visualization
- **Role-Based Access Control**: Separate permissions for Admin and User roles
- **Automated Notifications**: Queue-based email delivery with retry mechanisms
- **Data Retention**: Automatic cleanup of logs older than 7 days
- **High Performance**: Redis caching with PostgreSQL persistence

---

## üèóÔ∏è System Architecture

### Frontend-Backend Communication Flow

The LMS uses a modern client-server architecture with the following communication pattern:

1. **Frontend (React + Vite)**

   - Makes HTTP/HTTPS requests to the backend API
   - Uses **React Query** for data fetching, caching, and synchronization
   - Stores JWT tokens in memory/localStorage for authentication
   - Manages global state with **Zustand** (user data, filters, settings)
   - Implements optimistic updates for better UX

2. **API Communication**

   - **REST API** endpoints for all operations
   - **JSON** format for request/response payloads
   - **JWT tokens** in Authorization headers (`Bearer <token>`)
   - **CORS** enabled for cross-origin requests
   - **Rate limiting** to prevent abuse

3. **Backend (Express.js)**

   - Validates incoming requests (JWT verification, input validation)
   - Processes business logic through services layer
   - Queries Redis cache first, falls back to PostgreSQL
   - Returns standardized JSON responses
   - Emits events to queue system for async operations

4. **Data Flow Example** (User Login):
   ```
   Frontend                    Backend                    Database
   --------                    -------                    --------
   Login Form ‚Üí POST /api/auth/login ‚Üí Validate credentials ‚Üí PostgreSQL
                                     ‚Üê Generate JWT tokens ‚Üê
   Store tokens ‚Üê Return tokens & user data
   Update Zustand ‚Üê
   Redirect to Dashboard
   ```

### Architecture Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        CLIENT LAYER                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ         React Frontend (Vite + TypeScript)           ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Shadcn UI + Tailwind CSS                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ React Query for data management                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Zustand for state management                      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ÜïÔ∏è HTTPS/REST API
                    (JSON payloads + JWT tokens)
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                       API GATEWAY                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ         Express.js Backend (TypeScript)              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ JWT Authentication                                ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Rate Limiting & Security                          ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚Ä¢ Input Validation                                  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                            ‚ÜïÔ∏è
        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
        ‚Üì                                       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  INGESTION       ‚îÇ                  ‚îÇ  PROCESSING      ‚îÇ
‚îÇ  ‚Ä¢ HTTP API      ‚îÇ                  ‚îÇ  ‚Ä¢ Normalization ‚îÇ
‚îÇ  ‚Ä¢ Syslog        ‚îÇ                  ‚îÇ  ‚Ä¢ Alert Engine  ‚îÇ
‚îÇ  ‚Ä¢ Network       ‚îÇ    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚Üí     ‚îÇ  ‚Ä¢ Analytics     ‚îÇ
‚îÇ  ‚Ä¢ CrowdStrike   ‚îÇ                  ‚îÇ  ‚Ä¢ Aggregation   ‚îÇ
‚îÇ  ‚Ä¢ Agents        ‚îÇ                  ‚îÇ                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                              ‚Üì
                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                    ‚Üì                                        ‚Üì
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ  REDIS CACHE     ‚îÇ                    ‚îÇ  POSTGRESQL DB   ‚îÇ
          ‚îÇ  ‚Ä¢ Logs          ‚îÇ                    ‚îÇ  ‚Ä¢ Users         ‚îÇ
          ‚îÇ  ‚Ä¢ Alerts        ‚îÇ    ‚Üê‚îÄ Sync ‚îÄ‚Üí      ‚îÇ  ‚Ä¢ Alert Rules   ‚îÇ
          ‚îÇ  ‚Ä¢ Rules         ‚îÇ                    ‚îÇ  ‚Ä¢ Metadata      ‚îÇ
          ‚îÇ  ‚Ä¢ Sessions      ‚îÇ                    ‚îÇ                  ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ  QUEUE & WORKER  ‚îÇ
          ‚îÇ  ‚Ä¢ Email Queue   ‚îÇ
          ‚îÇ  ‚Ä¢ Retry Logic   ‚îÇ
          ‚îÇ  ‚Ä¢ OTP Delivery  ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                    ‚Üì
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
          ‚îÇ  SMTP SERVICE    ‚îÇ
          ‚îÇ  ‚Ä¢ Notifications ‚îÇ
          ‚îÇ  ‚Ä¢ Alerts        ‚îÇ
          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üîÑ How Frontend and Backend Work Together

The LMS uses a **client-server architecture** where the React frontend and Express backend communicate seamlessly:

### Communication Flow

1. **User Interaction** ‚Üí User performs an action (login, view logs, create alert)
2. **Frontend Request** ‚Üí React Query makes HTTP request to backend API endpoint
3. **Authentication** ‚Üí Backend validates JWT token from Authorization header
4. **Processing** ‚Üí Backend processes request, queries database, applies business logic
5. **Response** ‚Üí Backend returns JSON data to frontend
6. **UI Update** ‚Üí React Query updates cache and React re-renders components

### Example: Viewing Logs

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Frontend  ‚îÇ                                    ‚îÇ   Backend   ‚îÇ
‚îÇ   (React)   ‚îÇ                                    ‚îÇ  (Express)  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ                                                    ‚îÇ
      ‚îÇ  1. User clicks "View Logs"                       ‚îÇ
      ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>  ‚îÇ
      ‚îÇ     GET /api/get-logs                             ‚îÇ
      ‚îÇ     Headers: Authorization: Bearer <JWT>          ‚îÇ
      ‚îÇ                                                    ‚îÇ
      ‚îÇ                          2. Validate JWT token    ‚îÇ
      ‚îÇ                          3. Check Redis cache     ‚îÇ
      ‚îÇ                          4. Query PostgreSQL      ‚îÇ
      ‚îÇ                          5. Apply filters/pagination
      ‚îÇ                                                    ‚îÇ
      ‚îÇ  <‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ
      ‚îÇ     Response: { logs: [...], total: 1250 }        ‚îÇ
      ‚îÇ                                                    ‚îÇ
      ‚îÇ  6. React Query caches data                       ‚îÇ
      ‚îÇ  7. UI updates with logs table                    ‚îÇ
      ‚îÇ                                                    ‚îÇ
```

### Key Integration Points

| Aspect                | Frontend                                    | Backend                                                   |
| --------------------- | ------------------------------------------- | --------------------------------------------------------- |
| **Authentication**    | Stores JWT tokens, includes in all requests | Validates tokens, manages sessions                        |
| **Data Fetching**     | React Query with automatic caching          | REST API endpoints with JSON responses                    |
| **State Management**  | Zustand for global state (user, filters)    | Redis + PostgreSQL for persistence                        |
| **Real-time Updates** | Polling/refetch with React Query            | Background workers + queue system                         |
| **Form Handling**     | React Hook Form + Zod validation            | Express validators + Zod schemas                          |
| **Error Handling**    | Toast notifications, error boundaries       | Standardized error responses with codes                   |
| **Security**          | HTTPS, token storage, input sanitization    | JWT verification, rate limiting, SQL injection protection |

### Data Flow Patterns

**Pattern 1: Simple CRUD Operations**

```
Frontend ‚Üí API Call ‚Üí Backend ‚Üí Database ‚Üí Response ‚Üí UI Update
```

**Pattern 2: Complex Operations (e.g., Creating Alert Rule)**

```
Frontend ‚Üí API Call ‚Üí Backend ‚Üí Validate ‚Üí Store in DB  ‚Üí Response ‚Üí UI Update
```

**Pattern 3: Real-time Alerts**

```
Log Ingestion ‚Üí Alert Engine ‚Üí Match Rules ‚Üí Queue Email ‚Üí
Worker Sends ‚Üí Frontend Polls ‚Üí Updates Dashboard
```

### Environment Configuration

**Frontend (.env)**

```env
VITE_API_URL=http://localhost:3000/api  # Backend API base URL
```

**Backend (.env)**

```env
FRONTEND_URL=http://localhost:5173      # Frontend URL for CORS
```

These environment variables ensure the frontend knows where to send requests and the backend knows which origin to allow.

---

## üîÑ How the System Works: End-to-End Flow

### 1. Log Ingestion ‚Üí Normalization ‚Üí Alert Detection ‚Üí Email Notification

#### Step 1: Log Ingestion

```
External Sources               Backend API
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ             ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
HTTP Request    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>   POST /api/ingest
Syslog Server   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>   Syslog Listener
Network Feed    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>   Network Parser
CrowdStrike API ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>   Third-party Integration
Custom Agent    ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>   Agent Endpoint
```

**What happens:**

- Logs arrive from various sources in different formats (JSON, syslog, CSV, etc.)
- Backend receives raw log data
- Initial validation checks (authentication, rate limiting)

#### Step 2: Log Normalization

```javascript
// Raw log from different sources
Input 1: { "level": "ERROR", "msg": "Failed login", "ts": "2025-10-04T10:30:00Z" }
Input 2: <134>Oct 4 10:30:00 server: Failed login attempt
Input 3: 2025-10-04 10:30:00 | ERROR | Failed login

// After normalization - Unified schema
Output: {
  id: "log_123456",
  timestamp: "2025-10-04T10:30:00Z",
  level: "ERROR",
  message: "Failed login",
  source: "auth-service",
  userId: "user_789",
  metadata: { ip: "192.168.1.1", attempt: 3 }
}
```

**What happens:**

- Parser identifies log source type
- Extracts key fields (timestamp, level, message, source)
- Converts to standardized schema
- Enriches with metadata (IP, user info, geo-location)
- Validates normalized data

#### Step 3: Storage

```
Normalized Log
     ‚îÇ
     ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> Redis Cache (Fast access, 7-day TTL)
     ‚îÇ           ‚Ä¢ Key: log:{id}
     ‚îÇ           ‚Ä¢ Indexed by: timestamp, level, source
     ‚îÇ
     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ> PostgreSQL (Durable metadata storage)
                 ‚Ä¢ Stores log metadata
                 ‚Ä¢ User associations
                 ‚Ä¢ Audit trail
```

**What happens:**

- Log stored in Redis for fast retrieval
- Metadata stored in PostgreSQL for durability
- Indexed for efficient querying
- Automatic expiration set (7 days)

#### Step 4: Alert Rule Evaluation

```
Normalized Log
     ‚îÇ
     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Alert Engine (Real-time)      ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  1. Fetch active alert rules    ‚îÇ
‚îÇ     from Redis cache             ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  2. Check each rule:             ‚îÇ
‚îÇ     ‚Ä¢ Log level matches?         ‚îÇ
‚îÇ     ‚Ä¢ Source matches?            ‚îÇ
‚îÇ     ‚Ä¢ Keywords present?          ‚îÇ
‚îÇ     ‚Ä¢ Threshold exceeded?        ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  3. Rule matched? ‚îÄ‚îÄ> Create Alert
‚îÇ                                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Example Alert Rule:**

```javascript
{
  name: Failed Login Alert,
  tenant: demoA,
  description: Trigger alert if a user fails login with severity >= 3,
  conditions: [
    {
      type: event_type,
      value: LoginFailed
    }
  ]
}
```

**What happens:**

- System fetches all active alert rules
- Compares log against each rule's conditions
- If match found, creates alert object
- Stores alert in Redis + PostgreSQL
- Prepares for notification

#### Step 5: Queue Alert for Email

```
Alert Created
     ‚îÇ
     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Bull/BullMQ Queue System      ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  Job: {                          ‚îÇ
‚îÇ    type: "SEND_ALERT_EMAIL",     ‚îÇ
‚îÇ    data: {                       ‚îÇ
‚îÇ      alertId: "alert_456",       ‚îÇ
‚îÇ      recipients: [...],          ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ    },                            ‚îÇ
‚îÇ    attempts: 3,                  ‚îÇ
‚îÇ    backoff: exponential          ‚îÇ
‚îÇ  }                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**What happens:**

- Alert job added to email queue
- Job includes alert details and recipients
- Queue ensures reliable delivery (with retries)
- Jobs processed in order of priority

#### Step 6: Email Worker Processes Job

```
Email Worker (Background Process)
     ‚îÇ
     ‚îú‚îÄ 1. Pick job from queue
     ‚îÇ
     ‚îú‚îÄ 2. Fetch alert details from Redis
     ‚îÇ
     ‚îú‚îÄ 3. Generate email content
     ‚îÇ     ‚Ä¢ Subject: "[CRITICAL] Payment Service Alert"
     ‚îÇ     ‚Ä¢ Body: HTML template with log details
     ‚îÇ
     ‚îú‚îÄ 4. Send via Nodemailer + Gmail
     ‚îÇ     ‚Ä¢ Connect to Gmail SMTP
     ‚îÇ     ‚Ä¢ Authenticate with credentials
     ‚îÇ     ‚Ä¢ Send email
     ‚îÇ
     ‚îú‚îÄ 5. Update job status
     ‚îÇ     ‚Ä¢ Success: Mark complete
     ‚îÇ     ‚Ä¢ Failure: Retry (up to 3 times)
     ‚îÇ
     ‚îî‚îÄ 6. Log delivery status
```

**What happens:**

- Background worker picks job from queue
- Generates formatted email using template
- Sends email via Nodemailer
- Handles failures with retry logic (exponential backoff)
- Updates alert status in database

#### Step 7: User Views Alert in Dashboard

```
Frontend (React)
     ‚îÇ
     ‚îú‚îÄ React Query: GET /api/get-alerts
     ‚îÇ
     ‚ñº
Backend responds with alerts
     ‚îÇ
     ‚îú‚îÄ Check Redis cache first
     ‚îú‚îÄ Fallback to PostgreSQL if needed
     ‚îú‚îÄ Return JSON: { alerts: [...] }
     ‚îÇ
     ‚ñº
Frontend displays in UI
     ‚îÇ
     ‚îú‚îÄ Alert badge with count
     ‚îú‚îÄ Alert list with filters
     ‚îî‚îÄ Real-time updates (polling)
```

### Complete End-to-End Example

**Scenario:** Payment service generates 5 error logs within 2 minutes

```
Time: 10:00:00 - Log 1 ingested ‚Üí Normalized ‚Üí Stored ‚Üí Rule checked (no match yet)
Time: 10:00:30 - Log 2 ingested ‚Üí Normalized ‚Üí Stored ‚Üí Rule checked (no match yet)
Time: 10:01:00 - Log 3 ingested ‚Üí Normalized ‚Üí Stored ‚Üí Rule checked (no match yet)
Time: 10:01:30 - Log 4 ingested ‚Üí Normalized ‚Üí Stored ‚Üí Rule checked (no match yet)
Time: 10:02:00 - Log 5 ingested ‚Üí Normalized ‚Üí Stored ‚Üí Rule checked ‚úÖ MATCH!
                  ‚îÇ
                  ‚îî‚îÄ> Alert created ‚Üí Queued ‚Üí Worker processes ‚Üí Email sent

Time: 10:02:05 - Admin receives email: "5 payment errors in 2 minutes"
Time: 10:02:10 - Admin logs in ‚Üí Views alert dashboard ‚Üí Investigates logs
```

### Background Jobs & Scheduled Tasks

**Cron Job: Log Cleanup (Runs daily at 2 AM)**

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Log Cleanup Script            ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  1. Calculate cutoff date        ‚îÇ
‚îÇ     (current date - 7 days)      ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  2. Query Redis for old logs     ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  3. Delete from Redis            ‚îÇ
‚îÇ     ‚Ä¢ SCAN for log:* keys        ‚îÇ
‚îÇ     ‚Ä¢ Check timestamp            ‚îÇ
‚îÇ     ‚Ä¢ DEL old entries            ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  4. Clean PostgreSQL metadata    ‚îÇ
‚îÇ                                  ‚îÇ
‚îÇ  5. Log cleanup stats            ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**What happens:**

- Scheduled task runs daily
- Identifies logs older than 7 days
- Removes from Redis and PostgreSQL
- Frees up storage space
- Maintains system performance

---

## ‚ú® Features

### Frontend Features

- **Authentication**: Login, registration, OTP verification, password recovery
- **Role-Based UI**: Dynamic interface based on Admin/User permissions
- **Analytics Dashboard**: Interactive charts with Recharts
- **Advanced Filtering**: Multi-parameter search and filtering
- **Real-Time Updates**: Live alert notifications
- **Responsive Design**: Mobile-first approach with Tailwind CSS
- **Dark/Light Mode**: Theme switching with persistence
- **Optimized Performance**: Lazy loading, code splitting, caching

### Backend Features

- **Multi-Source Ingestion**: Support for various log sources
- **Log Normalization**: Unified schema for all log types
- **Alert Rule Engine**: Configurable rules with real-time evaluation
- **Queue System**: Reliable background job processing
- **Automated Cleanup**: Scheduled log retention (7 days)
- **RBAC**: Fine-grained access control
- **API Rate Limiting**: Protection against abuse
- **Comprehensive Testing**: Unit and integration tests

---

## üõ†Ô∏è Tech Stack

### Frontend

| Technology      | Purpose                 |
| --------------- | ----------------------- |
| React 19        | UI framework            |
| TypeScript      | Type safety             |
| Vite            | Build tool & dev server |
| Tailwind CSS    | Styling                 |
| Shadcn UI       | Component library       |
| React Query     | Data fetching & caching |
| Zustand         | State management        |
| React Hook Form | Form handling           |
| Zod             | Schema validation       |
| Recharts        | Data visualization      |
| Lucide React    | Icons                   |

### Backend

| Technology    | Purpose               |
| ------------- | --------------------- |
| Node.js 18+   | Runtime               |
| Express.js    | Web framework         |
| TypeScript    | Type safety           |
| PostgreSQL 15 | Primary database      |
| Redis 7.0     | Cache & session store |
| Prisma        | ORM                   |
| JWT           | Authentication        |
| Bull/BullMQ   | Queue system          |
| Nodemailer    | Email delivery        |
| Jest          | Testing framework     |

---

## üìã Prerequisites

Before you begin, ensure you have the following installed:

- **Node.js** >= 18.0.0
- **PostgreSQL** >= 15.0
- **Redis** >= 7.0
- **npm** or **yarn** or **pnpm**
- **Docker** & **Docker Compose** (optional)
- **Git**

---

## üöÄ Getting Started

### Clone the Repository

```bash
git clone https://github.com/yourusername/lms-project.git
cd lms-project
```

### Backend Setup

```bash
# Navigate to backend directory
cd backend

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env
# Edit .env with your configuration

# Run database migrations
npx prisma migrate dev

# Seed the database
npm run seed

# Start development server
npm run server:dev
```

### Frontend Setup

```bash
# Navigate to frontend directory (from project root)
cd frontend

# Install dependencies
npm install

# Set up environment variables
cp .env.example .env
# Edit .env with your backend API URL

# Start development server
npm run dev
```

### Using Docker (Recommended)

```bash
# From project root
docker-compose up -d

# View logs
docker-compose logs -f

# Stop services
docker-compose down
```

---

## ‚öôÔ∏è Environment Configuration

### Backend (.env)

```env
NODE_ENV=development
PORT=3000

# Database
DATABASE_URL=postgresql://postgres:password@localhost:5432/lms_db
DB_HOST=localhost
DB_PORT=5432
DB_NAME=lms_db
DB_USER=postgres
DB_PASSWORD=password

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
REDIS_PASSWORD=

# Authentication
ACCESS_TOKEN_SECRET=your-super-secret-access-token
REFRESH_TOKEN_SECRET=your-super-secret-refresh-token
JWT_EXPIRES_IN=15m
REFRESH_TOKEN_EXPIRES_IN=7d

# Email Configuration
SMTP_HOST=smtp.gmail.com
SMTP_PORT=587
SMTP_USER=your-email@gmail.com
SMTP_PASSWORD=your-app-password
EMAIL_FROM=noreply@lms.com

# Application
LOG_RETENTION_DAYS=7
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100
```

### Frontend (.env)

```env
VITE_API_URL=http://localhost:3000/api
VITE_APP_NAME=Log Management System
VITE_APP_VERSION=1.0.0
```

---

## üìÅ Project Structure

```
lms-project/
‚îú‚îÄ‚îÄ backend/                    # Backend application
‚îÇ   ‚îú‚îÄ‚îÄ prisma/                # Database schema & migrations
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ actions/          # Email actions & templates
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ config/           # Configuration files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ controllers/      # Request handlers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ jobs/             # Background jobs & workers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ middleware/       # Express middleware
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ routes/           # API routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scripts/          # Utility scripts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ services/         # Business logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tests/            # Test files
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/            # TypeScript types
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ utils/            # Helper functions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ app.ts            # Express app setup
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts          # Entry point
‚îÇ   ‚îú‚îÄ‚îÄ .env.example          # Example environment file
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ
‚îú‚îÄ‚îÄ frontend/                   # Frontend application
‚îÇ   ‚îú‚îÄ‚îÄ public/               # Static assets
‚îÇ   ‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api/              # API client functions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppComponents/    # Layout components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assets/           # Images, fonts, styles
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ components/       # Shadcn UI components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ data/             # Mock/sample data
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hooks/            # Custom React hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ lib/              # Utility libraries
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ pages/            # Page components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ router/           # Route configurations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Schemas/          # Zod validation schemas
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ store/            # Zustand stores
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ types/            # TypeScript types
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.css         # Global styles
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ main.tsx          # Entry point
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ routes.tsx        # Route definitions
‚îÇ   ‚îú‚îÄ‚îÄ .env.example          # Example environment file
‚îÇ   ‚îî‚îÄ‚îÄ package.json
‚îÇ
‚îú‚îÄ‚îÄ docker-compose.yml         # Docker services configuration
‚îú‚îÄ‚îÄ .gitignore
‚îî‚îÄ‚îÄ README.md                  # This file
```

---

## üîå API Documentation

### Authentication Endpoints

| Method | Endpoint                     | Description       | Access        |
| ------ | ---------------------------- | ----------------- | ------------- |
| POST   | `/api/auth/register`         | Register new user | Public        |
| POST   | `/api/auth/login`            | User login        | Public        |
| POST   | `/api/auth/verify-otp`       | Verify OTP        | Public        |
| POST   | `/api/auth/confirm-password` | Reset password    | Public        |
| POST   | `/api/auth/logout`           | User logout       | Authenticated |
| GET    | `/api/auth/auth-check`       | Check auth status | Authenticated |

### Log Management Endpoints

| Method | Endpoint                      | Description         | Access        |
| ------ | ----------------------------- | ------------------- | ------------- |
| POST   | `/api/ingest`                 | Ingest new logs     | Authenticated |
| GET    | `/api/get-logs`               | Retrieve all logs   | Authenticated |
| DELETE | `/api/delete-log/:logId`      | Delete specific log | Admin         |
| GET    | `/api/user-dashboard/:userId` | User dashboard data | User/Admin    |
| GET    | `/api/dashboard`              | System dashboard    | Admin         |
| GET    | `/api/get-all-data`           | Overall statistics  | Admin         |

### Alert Management Endpoints

| Method | Endpoint                | Description       | Access |
| ------ | ----------------------- | ----------------- | ------ |
| POST   | `/api/create-alertRule` | Create alert rule | Admin  |
| GET    | `/api/get-rules`        | Get all rules     | Admin  |
| DELETE | `/api/delete-rule/:id`  | Delete rule       | Admin  |

### User Management Endpoints

| Method | Endpoint                   | Description     | Access |
| ------ | -------------------------- | --------------- | ------ |
| POST   | `/api/create-user`         | Create new user | Admin  |
| GET    | `/api/get-users`           | Get all users   | Admin  |
| PUT    | `/api/update-user`         | Update user     | Admin  |
| DELETE | `/api/delete-user/:userId` | Delete user     | Admin  |

---

## üß™ Testing

### Backend Tests

```bash
cd backend

# Run all tests
npm test

# Run tests in watch mode
npm run test:watch

# Run tests with coverage
npm run test:coverage

# Run specific test file
npm test -- user_login.test.ts
```

### Frontend Tests

```bash
cd frontend

# Run tests (when configured)
npm test
```

---

## üì¶ Available Scripts

### Backend Scripts

```bash
npm start              # Run production build
npm run build          # Compile TypeScript
npm run server:dev     # Development server with hot-reload
npm run work           # Start email worker
npm run cache          # Start cache worker
npm run server         # Run all services
npm test               # Run tests
npm run log:cleanup    # Run log cleanup
npm run seed           # Seed database
```

### Frontend Scripts

```bash
npm run dev            # Development server
npm run build          # Production build
npm run preview        # Preview production build
npm run lint           # Run ESLint
```

---

## üö¢ Deployment

### Production Build

```bash
# Backend
cd backend
npm run build
npm start

# Frontend
cd frontend
npm run build
# Serve the dist/ folder with your web server
```

### Docker Deployment

```bash
# Build and start all services
docker-compose -f docker-compose.prod.yml up -d

# View logs
docker-compose logs -f

# Scale services
docker-compose up -d --scale worker=3
```

---

## üîí Security

- **Authentication**: JWT-based with refresh tokens
- **Password Hashing**: bcrypt with salt rounds
- **Security Headers**: Helmet.js middleware
- **Rate Limiting**: Prevents brute force attacks
- **Input Validation**: Zod schemas on all inputs
- **SQL Injection Protection**: Prisma ORM parameterized queries
- **XSS Protection**: React's built-in escaping
- **CORS**: Configured for specific origins

---

## ü§ù Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/AmazingFeature`)
3. Commit your changes (`git commit -m 'Add some AmazingFeature'`)
4. Push to the branch (`git push origin feature/AmazingFeature`)
5. Open a Pull Request

---

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

---

## üë• Authors

- **Your Name** - _Initial work_ - [YourGithub](https://github.com/yourusername)

---

## üôè Acknowledgments

- Shadcn UI for the excellent component library
- The React and Node.js communities
- All contributors who have helped this project

---

## üìû Support

For support, email support@lms.com or open an issue in the GitHub repository.

---

## üó∫Ô∏è Roadmap

- [ ] Implement WebSocket for real-time log streaming
- [ ] Add more log source integrations
- [ ] Implement log parsing with regex patterns
- [ ] Add export functionality (CSV, JSON, PDF)
- [ ] Implement log archiving to S3/Azure Blob
- [ ] Add advanced analytics with ML-based anomaly detection
- [ ] Mobile app development
- [ ] Kubernetes deployment configurations

---

**Made with ‚ù§Ô∏è by the LMS Team**


